// Generated by CoffeeScript 1.7.1
(function() {
  var SHORTHAND_TYPES, alwaysTrue, checkValidations, fTake, passesValidators, pfunk, r, _,
    __slice = [].slice;

  r = require('ramda');

  _ = require('lodash');

  fTake = function(n, list) {
    var i, nList, _i;
    nList = [];
    for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
      nList.push(list[i]);
    }
    return nList;
  };

  checkValidations = function(validations, value) {
    var fn, _i, _len;
    for (_i = 0, _len = validations.length; _i < _len; _i++) {
      fn = validations[_i];
      if (!fn(value)) {
        return false;
      }
    }
    return true;
  };

  alwaysTrue = function() {
    return true;
  };

  passesValidators = function(args, checks) {
    var checker_list, i, passed, v, _i, _len;
    passed = true;
    for (i = _i = 0, _len = args.length; _i < _len; i = ++_i) {
      v = args[i];
      checker_list = checks[i];
      if (checker_list == null) {
        checker_list = [alwaysTrue];
      }
      passed = passed && checkValidations(checker_list, v);
    }
    return passed;
  };

  SHORTHAND_TYPES = {
    "String": _.isString,
    "Function": _.isFunction,
    "Object": _.isObject,
    "Array": _.isArray,
    "Number": _.isNumber,
    "*": alwaysTrue
  };

  pfunk = function(base_fn, base_checks) {
    if (base_checks == null) {
      base_checks = {};
    }
    base_fn.withSignature = function() {
      var i, new_fn, new_registered_checks, v, validators, _fn, _i, _len;
      validators = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      new_registered_checks = _.cloneDeep(base_checks);
      _fn = function(v, i) {
        if (_.isString(v) && (SHORTHAND_TYPES[v] != null)) {
          v = SHORTHAND_TYPES[v];
        }
        if (new_registered_checks[i] != null) {
          return new_registered_checks[i].push(v);
        } else {
          return new_registered_checks[i] = [v];
        }
      };
      for (i = _i = 0, _len = validators.length; _i < _len; i = ++_i) {
        v = validators[i];
        _fn(v, i);
      }
      new_fn = r.arity(base_fn.length, function() {
        var args, args_to_check, num_args_to_check;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        num_args_to_check = Math.max(base_fn.length, args.length);
        args_to_check = fTake(num_args_to_check, args);
        if (args.length > 0 && passesValidators(args_to_check, new_registered_checks)) {
          return base_fn.apply(null, args);
        } else {
          throw new Error("NOPE");
        }
      });
      return pfunk(new_fn, new_registered_checks);
    };
    return base_fn;
  };

  pfunk.registerType = function(type_name, fn) {
    return SHORTHAND_TYPES[type_name] = fn;
  };

  module.exports = {
    pfunk: pfunk
  };

}).call(this);
